\documentclass[11pt]{article}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{microtype}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny,
  language=Python,
  showstringspaces=false
}

\title{Coding Club — Game Bot Manual}
\author{ChatGPT}
\date{\today}

\begin{document}
\maketitle


\section{Overview}
Players must implement an AI (a ``bot'') that chooses one action per turn. The engine will call your bot with the current game state and a history of previous states; your bot must return a single action string each call. This manual documents the inputs, outputs, and the available game data (inventory and character presets) that your bot can use to decide actions.

\section{Bot entry points}
The engine expects two functions (present in \texttt{bots.py}):

\begin{lstlisting}
def get_player_bot_action(current_game_state, game_archive):
    """
    Called for the player's bot.
    - current_game_state: dict describing current state (see section 4).
    - game_archive: list of previous game_state dicts (turn history).
    Must return a single action string (valid action strings listed in section 3).
    """

def get_opponent_bot_action(current_game_state, game_archive):
    """
    Called for the opponent bot.
    Same inputs/outputs as get_player_bot_action.
    """
\end{lstlisting}

Notes from the provided \texttt{bots.py}:
\begin{itemize}
  \item The sample player's bot in the provided file uses a simple heuristic: if player's HP is below a threshold (40) and a Potion exists, it returns \texttt{"Use Potion"}. Otherwise it returns other actions.
  \item The sample opponent bot in the provided file returns \texttt{"Attack"} every turn.
\end{itemize}

\section{Valid action strings}
Bots must return \textbf{one string} per call. Valid strings include:
\begin{itemize}
  \item \texttt{"Attack"}
  \item \texttt{"Defend"}
  \item \texttt{"Use <ItemName>"} \quad e.g. \texttt{"Use Potion"} or \texttt{"Use Bomb"}
  \item \texttt{"Cast <SkillName>"} \quad e.g. \texttt{"Cast Fireball"}
  \item (Menu/navigation strings sometimes used by menu-mode bots): \texttt{"NAV\_SKILLS"}, \texttt{"NAV\_ITEMS"}, \texttt{"NAV\_MAIN"}
\end{itemize}

\textbf{Important:} Item and skill names must match exactly the names used by the engine (case and spacing). If your bot returns a \texttt{"Use ..."} for an item you don't have or \texttt{"Cast ..."} for a skill when you lack the required skill points, the engine will treat it as an invalid or wasted action.

\section{Game state structure}
When your function is called it receives two arguments. The essential fields in \texttt{current\_game\_state} to use are:

\begin{lstlisting}
current_game_state = {
  "player": {
     "hp": int,
     "max_hp": int,
     "skill_points": int,
     "character_class": str,
  },
  "opponent": {
     "hp": int,
     "max_hp": int,
     "skill_points": int,
     "character_class": str,
  },
  "inventory": {
     "Potion": 3,
     "Ether": 1,
     "Bomb": 2,
     "Elixir": 0,
     ...
  }
}
\end{lstlisting}

\noindent The \texttt{game\_archive} is a list of prior game states (turn history). Use it to detect opponent patterns or past actions (e.g., if opponent uses the same skill repeatedly).

\section{Inventory presets}
Below are the inventory definitions available to bots (from \texttt{inventory\_presets.py}). These are the items, their counts and effects that a bot can inspect via \texttt{current\_game\_state["inventory"]}.

\subsection{Base inventory}
\begin{longtable}{@{}lp{7cm}r@{}}
\toprule
\textbf{Item} & \textbf{Effect / Description} & \textbf{Base count} \\
\midrule
Potion & Heals 30 HP & 3 \\
Ether & Heals 15 HP & 1 \\
Bomb & Deals 40 damage & 2 \\
Elixir & Fully restores HP (full heal) & 0 \\
\bottomrule
\end{longtable}

\subsection{Class-specific starting inventories}
(These are the starting inventory values that may be assigned for a selected class.)

\begin{longtable}{@{}lp{7cm}r@{}}
\toprule
\textbf{Class} & \textbf{Item \& effect} & \textbf{Count} \\
\midrule
Warrior & Potion (Heals 30 HP) & 4 \\
 & Ether (Heals 15 HP) & 1 \\
 & Bomb (Deals 40 damage) & 1 \\
 & Elixir (Full restore) & 0 \\
\addlinespace
Mage & Potion (Heals 30 HP) & (class-specific; typical presets give Mage more Ethers and at least 1 Elixir) \\
 & Ether (Heals 15 HP) & (see engine preset) \\
 & Bomb (Deals 40 damage) & (see engine preset) \\
 & Elixir (Full restore) & (see engine preset) \\
\addlinespace
Rogue & Potion (Heals 30 HP) & 3 \\
 & Ether (Heals 15 HP) & 2 \\
 & Bomb (Deals 40 damage) & 3 \\
 & Elixir (Full restore) & 0 \\
\bottomrule
\end{longtable}

\textit{Extra items (optional, may be present in some modes):}
\begin{itemize}
  \item \textbf{Mega Potion}: Heals 50 HP.
  \item \textbf{Smoke Bomb}: Utility/escape.
  \item \textbf{Antidote}: Cures poison.
\end{itemize}

\noindent \textbf{Practical bot notes for items:}
\begin{itemize}
  \item Always check inventory counts before returning a \texttt{"Use <Item>"} action.
  \item \texttt{"Use Potion"} consumes one Potion and heals a fixed amount (30 HP).
  \item \texttt{"Use Bomb"} deals fixed direct damage to the opponent (40 HP).
  \item \texttt{"Use Elixir"} fully restores HP (consumes the Elixir).
\end{itemize}

\section{Character presets and class skills}
Below is the \textbf{exact} content you provided for \texttt{character\_presets.py} and class skills. Include these in your bot logic when you inspect \texttt{current\_game\_state["player"]["character\_class"]}.

\subsection{Character presets (exact)}
\begin{lstlisting}
CHARACTER_PRESETS = [
    {
        "name": "Warrior",
        "max_hp": 120,
        "basic_attack_damage": (18, 25),
        "color": (200, 100, 50),
        "skill_points": 4,
        "defense": 15
    },
    {
        "name": "Mage",
        "max_hp": 80,
        "basic_attack_damage": (10, 16),
        "color": (100, 50, 200),
        "skill_points": 8,
        "defense": 25
    },
    {
        "name": "Rogue",
        "max_hp": 100,
        "basic_attack_damage": (15, 22),
        "color": (150, 150, 150),
        "skill_points": 6,
        "defense": 40
    }
]
\end{lstlisting}

\subsection{Class-specific skills (exact)}
\begin{lstlisting}
# WARRIOR_SKILLS
WARRIOR_SKILLS = {
    "Power Strike": {"damage": (30, 40), "cost": 3, "description": "Heavy weapon attack"},
    "Shield Bash": {"damage": (20, 30), "cost": 2, "description": "Stuns and damages"},
    "Battle Cry": {"heal": (15, 25), "cost": 3, "description": "Heals and boosts morale"},
    "Whirlwind": {"damage": (25, 35), "cost": 4, "description": "Hits all enemies"}
}

# MAGE_SKILLS
MAGE_SKILLS = {
    "Fireball": {"damage": (35, 45), "cost": 5, "description": "High damage fire spell"},
    "Ice Shard": {"damage": (25, 35), "cost": 3, "description": "Freezing damage"},
    "Arcane Heal": {"heal": (30, 40), "cost": 4, "description": "Powerful healing"},
    "Lightning Bolt": {"damage": (40, 50), "cost": 6, "description": "Massive lightning damage"}
}

# ROGUE_SKILLS
ROGUE_SKILLS = {
    "Backstab": {"damage": (35, 45), "cost": 4, "description": "High damage from behind"},
    "Poison Dart": {"damage": (0, 10), "cost": 3, "description": "Damage over time"},
    "Shadow Dodge": {"defense": 100, "cost": 3, "description": "Evade next attack"},
    "Quick Strike": {"damage": (25, 35), "cost": 2, "description": "Fast, low cost attack"}
}

# CLASS_SKILLS mapping
CLASS_SKILLS = {
    "Warrior": WARRIOR_SKILLS,
    "Mage": MAGE_SKILLS,
    "Rogue": ROGUE_SKILLS
}
\end{lstlisting}

\noindent Each skill entry may include:
\begin{itemize}
  \item \texttt{"damage"}: tuple (min,max) for damage done by the skill.
  \item \texttt{"heal"}: tuple (min,max) for heal amount.
  \item \texttt{"defense"}: numerical defense effect (e.g., 100 for Shadow Dodge).
  \item \texttt{"cost"}: skill point cost to cast the skill.
  \item \texttt{"description"}: text describing the skill.
\end{itemize}

\section{Example bots}
Below are two example bot implementations: (A) the simple heuristic from \texttt{bots.py} (as used in the provided file), and (B) a more robust template players can adapt.

\subsection{(A) Simple heuristic (from \texttt{bots.py})}
\begin{lstlisting}
import random

def get_player_bot_action(current_game_state, game_archive):
    """
    Simple logic:
    - If player HP < 40 and there is a Potion, use it.
    - Otherwise (fallback) choose attack or other actions.
    """
    player_hp = current_game_state['player']['hp']
    inventory = current_game_state['inventory']

    if player_hp < 40 and inventory.get("Potion", 0) > 0:
        return "Use Potion"

    # Fallback behaviour: attack each turn
    return "Attack"

def get_opponent_bot_action(current_game_state, game_archive):
    # Example opponent: always attack
    return "Attack"
\end{lstlisting}

\subsection{(B) Improved playable template}
This template demonstrates items and skills checks, and uses thresholds. Copy-paste and tune thresholds and skill names to match your strategy.

\begin{lstlisting}
import random

def get_player_bot_action(current_game_state, game_archive):
    me = current_game_state["player"]
    opp = current_game_state["opponent"]
    inv = current_game_state["inventory"]
    cls = me["character_class"]
    sp = me["skill_points"]

    # 1) Emergency heal
    if me["hp"] <= max(30, int(me["max_hp"]*0.35)) and inv.get("Potion", 0) > 0:
        return "Use Potion"

    # 2) Finish with Bomb if it's lethal
    if inv.get("Bomb", 0) > 0 and opp["hp"] <= 40:
        return "Use Bomb"

    # 3) Class-specific skill usage (example for Mage)
    if cls == "Mage" and sp >= 5:
        # Cast Fireball if we have enough skill points
        return "Cast Fireball"

    # 4) If opponent is low, use basic Attack
    if opp["hp"] <= 25:
        return "Attack"

    # 5) Otherwise random mix to avoid predictability
    if random.random() < 0.7:
        return "Attack"
    else:
        return "Defend"
\end{lstlisting}

\section{Bot design heuristics and tips}
\begin{itemize}
  \item \textbf{Exact names:} Item and skill names returned by your bot must match the definitions in the presets.
  \item \textbf{Check resources:} Always check \texttt{inventory[item]} and \texttt{skill\_points} before returning usage/cast actions.
  \item \textbf{Use the archive:} \texttt{game\_archive} can reveal opponent patterns (e.g., always defends on even turns).
  \item \textbf{Poison / DOT:} \texttt{Poison Dart} is damage-over-time; plan heals accordingly.
  \item \textbf{Defensive skills:} \texttt{Shadow Dodge} (Rogue) sets defense very high for the next attack — use it to negate heavy incoming damage.
  \item \textbf{Determinism for testing:} Seed random in your bot for reproducible behavior during debugging (e.g., \texttt{random.seed(42)}).
  \item \textbf{Avoid wasted actions:} Returning a \texttt{"Use ..."} for a non-existent item or \texttt{"Cast ..."} when insufficient SP will typically waste your turn.
\end{itemize}

\section{Quick reference (cheat sheet)}
\begin{itemize}
  \item \textbf{Function names:} \texttt{get\_player\_bot\_action(current\_game\_state, game\_archive)} and \texttt{get\_opponent\_bot\_action(...)}
  \item \textbf{Action strings:} \texttt{Attack}, \texttt{Defend}, \texttt{Use <ItemName>}, \texttt{Cast <SkillName>}
  \item \textbf{Items:} Potion (30 HP), Ether (15 HP), Bomb (40 damage), Elixir (full heal), possible Mega Potion / Smoke Bomb / Antidote.
  \item \textbf{Classes:} Warrior, Mage, Rogue (see Character Presets section for HP, damage ranges, SP, defense).
  \item \textbf{Class skills:} See \texttt{CLASS\_SKILLS} mapping in section 6.
\end{itemize}

\section{Appendix: quick copy-paste of class skills}
(Repeated for convenience; identical to section 6)
\begin{lstlisting}
CLASS_SKILLS = {
    "Warrior": {
        "Power Strike": {"damage": (30, 40), "cost": 3, ...},
        "Shield Bash": {"damage": (20, 30), "cost": 2, ...},
        "Battle Cry": {"heal": (15, 25), "cost": 3, ...},
        "Whirlwind": {"damage": (25, 35), "cost": 4, ...}
    },
    "Mage": {
        "Fireball": {"damage": (35, 45), "cost": 5, ...},
        "Ice Shard": {"damage": (25, 35), "cost": 3, ...},
        "Arcane Heal": {"heal": (30, 40), "cost": 4, ...},
        "Lightning Bolt": {"damage": (40, 50), "cost": 6, ...}
    },
    "Rogue": {
        "Backstab": {"damage": (35, 45), "cost": 4, ...},
        "Poison Dart": {"damage": (0, 10), "cost": 3, ...},
        "Shadow Dodge": {"defense": 100, "cost": 3, ...},
        "Quick Strike": {"damage": (25, 35), "cost": 2, ...}
    }
}
\end{lstlisting}


\bigskip
\noindent Good luck and have fun coding your bots!

\end{document}
